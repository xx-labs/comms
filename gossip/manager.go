package gossip

import (
	"github.com/spf13/jwalterweatherman"
	"gitlab.com/elixxir/primitives/id"
	"gitlab.com/xx_network/comms/connect"
	"google.golang.org/grpc"
	"sync"
	"time"
)

// Structure holding messages for a given tag, if the tag does not yet exist
// If the tag is not created in 5 minutes, the record should be deleted
type MessageRecord struct {
	Timestamp *time.Time
	Messages  []*GossipMsg
}

// Manager for various GossipProtocols that are accessed by tag
type Manager struct {
	// Stored map of GossipProtocols
	protocols    map[string]*Protocol
	protocolLock *sync.RWMutex // Lock for protocols object

	// Buffer messages with tags that do not have a protocol created yet
	buffer     map[string]*MessageRecord
	bufferLock *sync.RWMutex // Lock for buffers object
}

// Passed into NewGossip to specify how Gossip messages will be handled
type Receiver func(*GossipMsg) error

// Passed into NewGossip to specify how Gossip message signatures will be verified
type SignatureVerification func(*GossipMsg, []byte) error

// Creates a new Gossip Manager struct
func NewManager() *Manager {
	return &Manager{
		protocols:    map[string]*Protocol{},
		protocolLock: &sync.RWMutex{},
		buffer:       map[string]*MessageRecord{},
		bufferLock:   &sync.RWMutex{},
	}
}

// Creates and stores a new Protocol in the Manager
func (m *Manager) NewGossip(comms *connect.ProtoComms, tag string, flags Flags,
	receiver Receiver, verifier SignatureVerification, peers []*id.ID) {
	m.protocolLock.Lock()
	defer m.protocolLock.Unlock()

	tmp := Protocol{
		fingerprints:     map[Fingerprint]struct{}{},
		fingerprintsLock: sync.RWMutex{},
		comms:            comms,
		peers:            peers,
		peersLock:        sync.RWMutex{},
		flags:            flags,
		receiver:         receiver,
		verify:           verifier,
		IsDefunct:        false,
	}

	m.protocols[tag] = &tmp
}

// Registers the Gossip service with the endpoints. Both of these inputs
// are autogenerated by GRPC and may look different
func (m *Manager) GRPCRegister(s *grpc.Server, gs *GossipServer) {
	RegisterGossipServer(s, *gs)
}

// Returns the Gossip object for the provided tag from the Manager
func (m *Manager) Get(tag string) (*Protocol, bool) {
	m.protocolLock.RLock()
	defer m.protocolLock.RUnlock()

	p, ok := m.protocols[tag]
	return p, ok
}

// Deletes a Protocol from the Manager
func (m *Manager) Delete(tag string) {
	m.protocolLock.Lock()
	defer m.protocolLock.Unlock()

	delete(m.protocols, tag)
}

// Marks a Protocol as Defunct such that it will ignore new messages
func (m *Manager) Defunct(tag string) {
	m.protocolLock.Lock()
	defer m.protocolLock.Unlock()

	m.protocols[tag].IsDefunct = true
}

// Long-running thread to delete any messages in buffer older than 5m
func (m *Manager) bufferMonitor() error {
	killChan := make(chan bool, 0)
	bufferExpirationTime := int64(300) // Time in seconds that a record in the buffer should last

	for {
		for tag, record := range m.buffer {
			if p, ok := m.protocols[tag]; ok {
				m.bufferLock.Lock()
				for _, msg := range record.Messages {
					err := p.receive(msg)
					if err != nil {
						jwalterweatherman.WARN.Printf("Failed to receive message: %+v", msg)
					}
				}
				delete(m.buffer, tag)
				m.bufferLock.Unlock()
			} else if time.Now().Unix()-record.Timestamp.Unix() > bufferExpirationTime {
				m.bufferLock.Lock()
				delete(m.buffer, tag)
				m.bufferLock.Unlock()
			}
		}

		select {
		case <-killChan:
			return nil
		default:
			time.Sleep(3 * time.Second)
		}
	}
}
